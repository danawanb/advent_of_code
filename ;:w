use std::{collections::HashSet, fs};

pub fn day_ten() -> usize {
    let txt = fs::read_to_string("./src/day10_dummy.txt");

    let mut txt_i: Vec<String> = Vec::new();

    if let Ok(val) = txt {
        txt_i = val
            .split_whitespace()
            .map(|f| f.to_string())
            .into_iter()
            .collect();
    }

    let columns = txt_i.len();
    let rows = txt_i.len();

    let mut matrix: Vec<Vec<i8>> = vec![vec![0; columns]; rows];

    for (ids, s) in txt_i.iter().enumerate() {
        let char_vec: Vec<char> = s.chars().collect();
        for (idc, c) in char_vec.iter().enumerate() {
            matrix[ids][idc] = (*c as u8 - '0' as u8) as i8;
        }
    }

    for (id, i) in matrix.iter().enumerate() {
        for (idj, j) in i.iter().enumerate() {
            if *j == 0 {
                let pos = Position {
                    value: 0,
                    x: idj as i8,
                    y: id as i8,
                    next_post: Box::new(None),
                };

                //println!("{} {}", id as i8 - 1 as i8, idj);
                let mut top: i8 = 0;
                //check top
                if id as i8 - 1 as i8 > 0 {
                    top = matrix[id - 1][idj];
                }

                let mut right: i8 = 0;
                //check right
                if idj < matrix[id].len() {
                    right = matrix[id][idj + 1];
                }

                let mut bottom: i8 = 0;
                //check bottom
                if id < matrix.len() - 1 {
                    bottom = matrix[id + 1][idj];
                }

                let mut left: i8 = 0;
                if idj > 0 {
                    left = matrix[id][idj - 1];
                }

                let near = NearPosition {
                    top,
                    right,
                    bottom,
                    left,
                };

                let mut next: Option<Position> = None;
            }
        }
    }
    6
}

#[derive(Debug, Clone)]
struct Position {
    value: i8,
    x: i8,
    y: i8,
    next_post: Box<Option<Position>>,
}

#[derive(Debug, Clone, Copy)]
struct NearPosition {
    top: i8,
    right: i8,
    bottom: i8,
    left: i8,
}

fn search_next_value(mut current_val: Position, near: Option<NearPosition>) -> Option<Position> {
    if near.unwrap().top == current_val.value + 1 {
        let pos = Position {
            value: current_val.value + 1,
            x: current_val.x,
            y: current_val.y - 1,
            next_post: Box::new(None),
        };

        current_val.next_post = Box::new(Some(pos));
        return Some(current_val);
    }

    if near.unwrap().right == current_val.value + 1 {
        let pos = Position {
            value: current_val.value + 1,
            x: current_val.x + 1,
            y: current_val.y,
            next_post: Box::new(None),
        };

        current_val.next_post = Box::new(Some(pos));
        return Some(current_val);
    }

    if near.unwrap().bottom == current_val.value + 1 {
        let pos = Position {
            value: current_val.value + 1,
            x: current_val.x,
            y: current_val.y + 1,
            next_post: Box::new(None),
        };

        current_val.next_post = Box::new(Some(pos));
        return Some(current_val);
    }

    None
}

fn search_trail(
    x: usize,
    y: usize,
    matrix: &Vec<Vec<i32>>,
    end_positions: &mut HashSet<(usize, usize)>,
) {
    let height = matrix[y][x];
    if height == 9 {
        end_positions.insert((x, y));
        return;
    }

    // kiri
    if x > 0 && matrix[y][x - 1] == height + 1 {
        search_trail(x - 1, y, matrix, end_positions);
    }

    // atas
    if y > 0 && matrix[y - 1][x] == height + 1 {
        search_trail(x, y - 1, matrix, end_positions);
    }

    // kanan
    if x < matrix[y].len() - 1 && matrix[y][x + 1] == height + 1 {
        search_trail(x + 1, y, matrix, end_positions);
    }

    // bawah
    if y < matrix.len() - 1 && matrix[y + 1][x] == height + 1 {
        search_trail(x, y + 1, matrix, end_positions);
    }
}
